



## msf

msfconsole 은 context 로 관리된다. 
그러니까 전역 변수로 세팅되지 않으면 모든 파라미터 세팅들은 사용하고자 하는 모듈을 변경하면 날아갈거다.
로컬 변수 세팅은 
`set rhosts 10.10.165.39`
전역 변수 세팅은 
`setg rhosts 10.10.165.39`
로 가능하다

use module
을 하게되면 context 가 변경됨. 이를 enter 라고 함. 

`show options`
는 선택한 exploit 과 관련된 옵션들을 출력해줌. 
context 에 따라 다른 출력물일것이다. 이를 테면 RHOSTS, RPORT 같은 variable 을 세팅하라고 할 것이다. 
반면에 post-exploitation module 은 SESSION ID 만 요구할 것이다. 
session 은 post-exploitation module 이 사용할 target system 에 존재하는 연결을 의미함. 

`show payloads`

`back` command 를 사용하면 context 를 벗어날 수 있음. 
`info` 를 context 내에서 모듈에 대한 사용하면 많은 정보를 준다.

`search` command 를 사용하면 CVE 와 관련된 exploit 들을 검색해줌. 
그러니까 함께 준 search parameter 와 관련된 모듈들을 찾아주는 것임. 
예를 들면, CVE number 나 exploit name(eternealblue, heartbleed, 등등) 혹은 타겟 시스템을 사용해서 검색을 수행할 수 있다는 것 

Meterpreter ; 
meterpreter agent 라는 Payload 가 있음. 이게 target system 에 로드돼서 얘가 내 컴퓨터에 다시 접속하는 형태로 연결되면 meterpreter prompt 로 볼 수 있음. 

# 모듈 사용하기

모든 모듈 파라미터를 설정했다면 이제 `exploit` 커맨드를 사용해서 모듈을 실행시킬 수 있다. 
run 이라고 하는 커맨드도 alias 로 제공되는데 그 이유는 exploit 이 아닌 모듈들에 exploit 을 하는게 말이 안되기 때문이다. 
예를 들면 port scanner, vulnerability scanner 같은 것들을 실행하는데 exploit 이라고 하는 것은 이상하기 때문. 

exploit -z 로 실행하면 exploit 을 실행하고 session 이 열리자마자 session 을 background 로 감춤


# 세션

vulnerability 가 성공적으로 exploit 되면 session 이 생성될 것이다. target system 과 metasploit 간에 생성된 통신 채널임. 

background command 를 이용해서 session prompt 를 background 로 감추고 msfconsole prompt 로 돌아갈 수 있음. 
혹은 ctrl+z 로도 백그라운드로 만들 수 있음. 


sessions command 로 현재 존재하는 session 들을 확인할 수 있음. 
세션에 붙으려면 session -i 2 이런 식으로 attach 가능


# db 이용하기

postgresql 을 서비스로 실행함
systemctl start postgresql 
database init
msfdb init
workspace add
workspace -a tryhackme
nmap 으로 스캔한 결과물을 모두 db 에 저장
db_nmap -sV -p- 10.10.12.229
db 에 저장된 결과를 기반으로 host 들 나열
hosts
서비스들 나열
services


Metasploit 을 사용하면 어떤 치명적인 취약점도 'low hanging fruit' 으로 보이게 된다. 
쉽게 파악하고 이용할 수 있는 취약점이란 뜻이다. 그리고 어떤 시스템에 대한 발판을 얻게 해줄 수 있고 어떤 경우에는 root 또는 관리자 권한을 얻게 해줄 수 있다는 뜻이다. 

Metasploit 을 사용해서 취약점을 찾는 것은 대상에 대해 scan 하고 fingerprint 를 하는 것에 크게 의존한다. 
이런 단계에서 더 잘할수록 MEtasploit 은 더 많은 옵션들을 제공할 것이다. 
예를 들면 target system 에 돌고 있는 vnc service 가 있을 때 Metasploit 에서 search function 을 사용할 수 있다. 
그 결과는 payload 와 post module 들을 갖고 있다. 


대부분의 exploit 들은 default payload 프리셋을 지니고 있을텐데, 언제든지 show payload 를 사용해서 사용할 수 있는 목록들을 볼 수 있음. 

잘 동작하는 payload 를 선택하는 거는 trial and error 가 될 수도 있다. 왜냐하면 방화벽 룰, 안티바이러스 같은 OS 제한이나 환경제한 때문에.

msfvenom 은 msfpayload 랑 msfencode 를 대체해버린 녀석이고 이게 payload 를 생성하도록 도와줄 것이다. 

msfvenom 이 metasploit framework 상에서 가능한 모든 payload 에 접근할 수 있게 해준다. 그리고 매우 다른 포맷들에서 payload 를 생성하게 해줄 것이다. 
예를 들면 php, exe, dll, elf 등의 포맷들. 그리고 다양한 target system 에 대해 가능함. 


Encoders 

일반적인 상식과 반대로 encoders 는 antivirus 를 우회하는게 목표가 아니다. 이름이 암시하는 것과 같이 payload 를 encode 할 뿐이다. 
어떤 antivirus software 에 대해서 효과적일 수 있으나 현대 난독화 기술을 사용하거나 shellcode 를 삽입하는 방법을 배우는 것이 더 좋은 우회방법이다. 
encoding 예시는 다음과 같음
-e param 을 이용해서 php version 의 meterpreter 가 base64 로 인코딩 되고 output format 은 raw다. 


Handlers

reverse shell 을 사용하는 exploit 과 유사하게 MSFvenom payload 에 의해 생성된 incoming connection 을 받아야할 수도 있다. 
exploit omdule 을 사용할 때 이 부분이 자동으로 exploit module 에 의해 처리가 된다. 이 때 reverse shell 을 구성할 때 어떻게 payload options title 이 보여질지 기억할 거다. catching a shell 이라는 용어가 일반적으로 target 으로부터 연결을 받는다는 용어로 사용된다. reverse shell 이나 meterpreter callbacks 들은 쉽게 handler 를 사용해서 catch 할 수 있음. 


Generate the PHP shell using MSFvenom
Start the Metasploit handler
Execute the PHP shell
MSFvenom will require a payload, the local machine IP address, and the local port to which the payload will connect. Seen below, 10.0.2.19 is the IP address of the AttackBox used in the attack and local port 7777 was chosen.
